# rally_detector.py - Phase 3: Rally Detection System
from AlgorithmImports import *
from datetime import datetime, time, timedelta

class RallyDetector:
    """
    Phase 3: Rally Detection System - MOMENTUM GATE FOR EXISTING CONDITIONS
    
    This module implements the 5-parameter rally detection system that acts as
    a momentum gate for existing entry conditions. Rally detection ENHANCES
    but does NOT replace the existing 4 entry conditions from previous phases.
    
    Parameters used:
    - Rally_X_Min_PCT: Rally X minimum percentage (rally_x_min_pct)
    - Rally_X_Max_PCT: Rally X maximum percentage (rally_x_max_pct)  
    - Rally_Y_PCT: Rally Y percentage threshold (rally_y_pct)
    - Rally_Time_Constraint: Rally time constraint in MINUTES (rally_x_rally_y_time_constraint)
    - Rally_Time_Constraint_Threshold: Rally threshold multiplier (threshold)
    """
    
    def __init__(self, algorithm, params):
        self.algorithm = algorithm
        self.params = params
        self.data_cache = []  # Store 15-second price data
        self.market_open = time(9, 30)  # 9:30 AM
        self.market_close = time(15, 59)  # 3:59 PM
        
        self.algorithm.Log(f"{self.algorithm.Time} - RallyDetector initialized - Phase 3 momentum gate system")
    
    def update_price_data(self, symbol, bar_data):
        """
        Store 15-second price data for rally calculations
        Called from main algorithm on each price update
        """
        timestamp = self.algorithm.Time
        
        # Only store data during market hours
        if not self.is_market_hours(timestamp):
            return
            
        price_data = {
            'symbol': symbol,
            'time': timestamp,
            'high': float(bar_data.High),
            'low': float(bar_data.Low),
            'close': float(bar_data.Close),
            'open': float(bar_data.Open)
        }
        
        self.data_cache.append(price_data)
        
        # Keep only recent data (rolling window - keep last 4 hours of 15-second data)
        max_entries = 4 * 60 * 4  # 4 hours * 60 minutes * 4 (15-second intervals per minute)
        if len(self.data_cache) > max_entries:
            self.data_cache = self.data_cache[-max_entries:]
    
    def is_market_hours(self, timestamp):
        """Check if timestamp is within market hours (9:30 AM - 3:59 PM)"""
        current_time = timestamp.time()
        return self.market_open <= current_time <= self.market_close
    
    def filter_market_hours_data(self, symbol):
        """Filter cached data for market hours only and specific symbol"""
        return [d for d in self.data_cache 
                if d['symbol'] == symbol and self.is_market_hours(d['time'])]
    
    def check_long_rally_condition(self, symbol, metrics):
        """
        Validate upward rally momentum for LONG conditions (C1, C2) - Reference implementation
        
        Matches Reference rally_condition() method exactly
        
        Returns: True if rally momentum supports LONG entry, False otherwise
        """
        try:
            # Filter 15-second data for market hours only (9:30-15:59) - HARDCODED like Reference
            filtered = self.filter_market_hours_data(symbol)
            
            if len(filtered) < 10:  # Need minimum data points
                return False
                
            # Find momentum extremes (matches Reference lines 1116-1119)
            lows = [(i, d['low'], d['time']) for i, d in enumerate(filtered)]
            highs = [(i, d['high'], d['time']) for i, d in enumerate(filtered)]
            
            # Find lowest point and its time
            lowest_idx, lowest_price, lowest_time = min(lows, key=lambda x: x[1])
            # Find highest point and its time
            highest_idx, highest_price, highest_time = max(highs, key=lambda x: x[1])
            
            # Rally X: Measure upward momentum (lowest to highest) - Reference lines 1120-1123
            metric_range_price = metrics.metric_range_price
            rally_x = ((highest_price - lowest_price) * 100.0 / lowest_price) / metric_range_price
            rally_x_condition = (rally_x >= (self.params.Rally_X_Min_PCT/100.0)) and \
                               (rally_x <= (self.params.Rally_X_Max_PCT/100.0))
            
            # Rally Y: Measure pullback from high (highest to current low) - Reference lines 1124-1127
            last_low = filtered[-1]['low']  # filtered[-1, LOW]
            last_low_time = filtered[-1]['time']
            rally_y = abs((highest_price - last_low) * 100.0 / highest_price) / metric_range_price
            rally_y_condition = rally_y >= (self.params.Rally_Y_PCT/100.0)
            
            # Time constraint validation - matches Reference lines 1149-1150
            # delta = last_low_date - lowest_date
            time_constraint = self.validate_time_constraint_long(symbol, metrics, lowest_time, last_low_time)
            
            result = rally_x_condition and rally_y_condition and time_constraint
            
            # Log rally details with symbol and timestamp including thresholds
            rally_x_min_threshold = self.params.Rally_X_Min_PCT/100.0
            rally_x_max_threshold = self.params.Rally_X_Max_PCT/100.0
            rally_y_threshold = self.params.Rally_Y_PCT/100.0
            self.algorithm.Log(f"{self.algorithm.Time} - RALLY LONG {symbol}: Rally X={rally_x:.3f} [need {rally_x_min_threshold:.3f}-{rally_x_max_threshold:.3f}] ({rally_x_condition}), Rally Y={rally_y:.3f} [need ≥{rally_y_threshold:.3f}] ({rally_y_condition}), Time OK={time_constraint}")
            
            return result
            
        except Exception as e:
            self.algorithm.Log(f"{self.algorithm.Time} - RALLY LONG ERROR - {symbol}: {e}")
            return False
    
    def check_short_rally_condition(self, symbol, metrics):
        """
        Validate downward rally momentum for SHORT conditions (C4, C5) - Reference implementation
        
        Matches Reference rally_cond_short() method exactly
        
        Returns: True if rally momentum supports SHORT entry, False otherwise
        """
        try:
            # Filter 15-second data for market hours only (9:30-15:59) - HARDCODED like Reference
            filtered = self.filter_market_hours_data(symbol)
            
            if len(filtered) < 10:  # Need minimum data points
                return False
                
            # Find momentum extremes (matches Reference lines 1170-1173)
            highs = [(i, d['high'], d['time']) for i, d in enumerate(filtered)]
            lows = [(i, d['low'], d['time']) for i, d in enumerate(filtered)]
            
            # Find highest point and its time
            highest_idx, highest_price, highest_time = max(highs, key=lambda x: x[1])
            # Find lowest point and its time
            lowest_idx, lowest_price, lowest_time = min(lows, key=lambda x: x[1])
            
            # Rally X: Measure downward momentum (highest to lowest) - Reference lines 1174-1177
            metric_range_price = metrics.metric_range_price
            rally_x = ((highest_price - lowest_price) * 100.0 / highest_price) / metric_range_price
            rally_x_condition = (rally_x >= (self.params.Rally_X_Min_PCT/100.0)) and \
                               (rally_x <= (self.params.Rally_X_Max_PCT/100.0))
            
            # Rally Y: Measure bounce from low (lowest to current high) - Reference lines 1178-1181
            last_high = filtered[-1]['high']  # filtered[-1, HIGH]
            last_high_time = filtered[-1]['time']
            rally_y = abs((last_high - lowest_price) * 100.0 / lowest_price) / metric_range_price
            rally_y_condition = rally_y >= (self.params.Rally_Y_PCT/100.0)
            
            # Time constraint validation - matches Reference lines 1149-1150
            # delta = last_high_date - highest_date
            time_constraint = self.validate_time_constraint_short(symbol, metrics, highest_time, last_high_time)
            
            result = rally_x_condition and rally_y_condition and time_constraint
            
            # Log rally details with symbol and timestamp including thresholds
            rally_x_min_threshold = self.params.Rally_X_Min_PCT/100.0
            rally_x_max_threshold = self.params.Rally_X_Max_PCT/100.0
            rally_y_threshold = self.params.Rally_Y_PCT/100.0
            self.algorithm.Log(f"{self.algorithm.Time} - RALLY SHORT {symbol}: Rally X={rally_x:.3f} [need {rally_x_min_threshold:.3f}-{rally_x_max_threshold:.3f}] ({rally_x_condition}), Rally Y={rally_y:.3f} [need ≥{rally_y_threshold:.3f}] ({rally_y_condition}), Time OK={time_constraint}")
            
            return result
            
        except Exception as e:
            self.algorithm.Log(f"{self.algorithm.Time} - RALLY SHORT ERROR - {symbol}: {e}")
            return False
    
    def validate_time_constraint_long(self, symbol, metrics, lowest_time, last_low_time):
        """
        Check rally timing requirements for LONG positions
        Matches Reference lines 1149-1150: delta = last_low_date - lowest_date
        
        Args:
            symbol: Trading symbol
            metrics: Metrics calculator instance
            lowest_time: Timestamp of the lowest price point
            last_low_time: Timestamp of the most recent low
        """
        try:
            # Get metric_range_multiplier from metrics
            metric_range_multiplier = metrics.metric_range_multiplier
            
            # Check if time constraint applies
            if metric_range_multiplier > self.params.Rally_Time_Constraint_Threshold:
                # Calculate actual rally duration from lowest to last low
                delta = last_low_time - lowest_time
                rally_duration_minutes = delta.total_seconds() / 60  # Convert to minutes
                required_minutes = self.params.Rally_Time_Constraint  # Already in minutes
                
                if rally_duration_minutes < required_minutes:
                    self.algorithm.Log(f"{self.algorithm.Time} - RALLY TIME CONSTRAINT FAILED {symbol} LONG - Duration: {rally_duration_minutes:.1f}min < Required: {required_minutes:.1f}min")
                    return False
                    
                self.algorithm.Log(f"{self.algorithm.Time} - RALLY TIME CONSTRAINT OK {symbol} LONG - Duration: {rally_duration_minutes:.1f}min >= Required: {required_minutes:.1f}min")
            
            return True
            
        except Exception as e:
            self.algorithm.Log(f"{self.algorithm.Time} - RALLY TIME CONSTRAINT ERROR {symbol}: {e}")
            return True  # Default to allowing if error
    
    def validate_time_constraint_short(self, symbol, metrics, highest_time, last_high_time):
        """
        Check rally timing requirements for SHORT positions
        Matches Reference: delta = last_high_date - highest_date
        
        Args:
            symbol: Trading symbol
            metrics: Metrics calculator instance
            highest_time: Timestamp of the highest price point
            last_high_time: Timestamp of the most recent high
        """
        try:
            # Get metric_range_multiplier from metrics
            metric_range_multiplier = metrics.metric_range_multiplier
            
            # Check if time constraint applies
            if metric_range_multiplier > self.params.Rally_Time_Constraint_Threshold:
                # Calculate actual rally duration from highest to last high
                delta = last_high_time - highest_time
                rally_duration_minutes = delta.total_seconds() / 60  # Convert to minutes
                required_minutes = self.params.Rally_Time_Constraint  # Already in minutes
                
                if rally_duration_minutes < required_minutes:
                    self.algorithm.Log(f"{self.algorithm.Time} - RALLY TIME CONSTRAINT FAILED {symbol} SHORT - Duration: {rally_duration_minutes:.1f}min < Required: {required_minutes:.1f}min")
                    return False
                    
                self.algorithm.Log(f"{self.algorithm.Time} - RALLY TIME CONSTRAINT OK {symbol} SHORT - Duration: {rally_duration_minutes:.1f}min >= Required: {required_minutes:.1f}min")
            
            return True
            
        except Exception as e:
            self.algorithm.Log(f"{self.algorithm.Time} - RALLY TIME CONSTRAINT ERROR {symbol}: {e}")
            return True  # Default to allowing if error
    
    def reset_daily_data(self):
        """Reset rally detector for new trading day"""
        self.data_cache.clear()
        self.algorithm.Log(f"{self.algorithm.Time} - RallyDetector reset for new trading day")
    
    def get_rally_statistics(self, symbol):
        """Get current rally statistics for debugging/monitoring"""
        market_data = self.filter_market_hours_data(symbol)
        
        if len(market_data) < 2:
            return None
            
        lows = [d['low'] for d in market_data]
        highs = [d['high'] for d in market_data]
        
        return {
            'data_points': len(market_data),
            'lowest': min(lows),
            'highest': max(highs),
            'current_low': market_data[-1]['low'],
            'current_high': market_data[-1]['high'],
            'duration_minutes': self.calculate_rally_duration()
        }
    
    def check_long_rally_with_reset(self, symbol, metrics):
        """
        Check rally condition and return reset flag for LONG conditions (Reference-style)
        
        Returns: (rally_result, reset_required)
        """
        try:
            # Rally calculation logic (same as check_long_rally_condition)
            rally_result = self.check_long_rally_condition(symbol, metrics)
            
            # Determine if conditions should be reset (Reference logic)
            # Reset when rally conditions change unfavorably
            reset_required = self.should_reset_conditions_long(symbol, metrics)
            
            return rally_result, reset_required
            
        except Exception as e:
            self.algorithm.Log(f"{self.algorithm.Time} - RALLY LONG WITH RESET ERROR - {symbol}: {e}")
            return False, True  # Error = reset conditions
    
    def check_short_rally_with_reset(self, symbol, metrics):
        """
        Check rally condition and return reset flag for SHORT conditions (Reference-style)
        
        Returns: (rally_result, reset_required)
        """
        try:
            # Rally calculation logic (same as check_short_rally_condition)
            rally_result = self.check_short_rally_condition(symbol, metrics)
            
            # Determine if conditions should be reset (Reference logic)
            # Reset when rally conditions change unfavorably
            reset_required = self.should_reset_conditions_short(symbol, metrics)
            
            return rally_result, reset_required
            
        except Exception as e:
            self.algorithm.Log(f"{self.algorithm.Time} - RALLY SHORT WITH RESET ERROR - {symbol}: {e}")
            return False, True  # Error = reset conditions
    
    def should_reset_conditions_long(self, symbol, metrics):
        """
        Determine if LONG conditions should be reset based on rally deterioration
        
        Reference logic: Reset when rally momentum is lost or unfavorable
        """
        try:
            filtered = self.filter_market_hours_data(symbol)
            
            if len(filtered) < 5:
                return True  # Reset if insufficient data
                
            # Check if recent price action shows rally deterioration
            recent_data = filtered[-5:]  # Last 5 data points
            recent_lows = [d['low'] for d in recent_data]
            recent_highs = [d['high'] for d in recent_data]
            
            # Check for significant downward trend in recent data
            if len(recent_data) >= 3:
                trend_decline = (recent_highs[0] - recent_lows[-1]) / recent_highs[0]
                if trend_decline > 0.02:  # 2% decline suggests rally failure
                    return True
                    
            return False  # Don't reset by default
            
        except Exception as e:
            self.algorithm.Log(f"{self.algorithm.Time} - RESET CHECK LONG ERROR - {symbol}: {e}")
            return True  # Reset on error to be safe
    
    def should_reset_conditions_short(self, symbol, metrics):
        """
        Determine if SHORT conditions should be reset based on rally deterioration
        
        Reference logic: Reset when rally momentum is lost or unfavorable
        """
        try:
            filtered = self.filter_market_hours_data(symbol)
            
            if len(filtered) < 5:
                return True  # Reset if insufficient data
                
            # Check if recent price action shows rally deterioration
            recent_data = filtered[-5:]  # Last 5 data points
            recent_lows = [d['low'] for d in recent_data]
            recent_highs = [d['high'] for d in recent_data]
            
            # Check for significant upward trend in recent data
            if len(recent_data) >= 3:
                trend_incline = (recent_highs[-1] - recent_lows[0]) / recent_lows[0]
                if trend_incline > 0.02:  # 2% incline suggests short rally failure
                    return True
                    
            return False  # Don't reset by default
            
        except Exception as e:
            self.algorithm.Log(f"{self.algorithm.Time} - RESET CHECK SHORT ERROR - {symbol}: {e}")
            return True  # Reset on error to be safe